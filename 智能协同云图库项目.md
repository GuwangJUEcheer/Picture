## 智能协同云图库

### 1 项目概要

基于Vue3 + SpringBoot + COS + WebSocket的企业级智能协同云图库

核心功能

1. 所有用户可以在平台公开上传 检索图片素材

2. 管理员可以上传审核 管理图片 并且对系统内的图片进行分析

3. 对于个人用户 可以将图片上传到私有空间 批量检索 编辑 分析(个人空间)

4. 邀请成员 共享图片 实时协同编辑图片样式

   系统架构如下

![image-20250209214813247](C:\Users\17685\AppData\Roaming\Typora\typora-user-images\image-20250209214813247.png)

### 2025/2/11

#### 项目初始化

Idea 里面server URL 改成 start.aliyun.com  提供低版本的java

springboot2.7.6 java 8 

为什么 3  ->3不稳定

**依赖**

+ SpringWeb

+ Mybatis Framework

+ mysql

+ lombok

+ hubtool //这个是各种小工具 字符串 日期等等

  ```xml
  <dependency>
      <groupId>cn.hutool</groupId>
      <artifactId>hutool-all</artifactId>
      <version>5.8.35</version>
  </dependency>
  ```

+ 整合aop的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

在启动类上面 加上@EnableAspectJAutoProxy(exposeProxy = true) 为某个对象增加代理 获得代理 AopContext.currentProxy 获得现在代理

**补充 动态代理**

前提:动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。

jdk实现的方法

- [java.lang.reflect Proxy](https://link.segmentfault.com/?enc=zxmqQ%2BZfSqBLsVG4asQxrw%3D%3D.t7kBjy2yTlYJsOf%2F%2FFbh%2F3q4VrPBIpneOQBOpMUqzhzRBIuJwsHytB8sNE8EqZ17pC44E%2F7fMzFH2DetiMDn4fjwoiPvI9LVf3iHumqTR3s%3D)，主要方法为

  ```java
  static Object    newProxyInstance(ClassLoader loader,  //指定当前目标对象使用类加载器
       Class<?>[] interfaces,    //目标对象实现的接口的类型
       InvocationHandler h      //事件处理器
  )
  ```

- [java.lang.reflect InvocationHandler](https://link.segmentfault.com/?enc=yIKyIpEvuXJONbXoqhoJzg%3D%3D.2CsdCjTixC4YPOOjOfCRG%2BRGY57VKHX6ePaSvhCCW0gM5oUEK9sxehiLjPfF7ykrG%2FNuJIowUlG9hcfzeygLga1IlVP85NSWeGda0MbrtyVxPtqXl%2FjlL7bzCqgGNGf%2B)，主要方法为

  ```
   Object invoke(Object proxy, Method method, Object[] args) 
  // 在代理实例上处理方法调用并返回结果。
  ```

- aop作用就是给某个对象提供代理

 **开发第一步 先写基础代码** 一些通用的代码

**前端的工具** webstorm **组件库** Ant design vue

```bash
$ npm i --save ant-design-vue@4.x
```

#### 消除vue导入.vue的类型检查

在项目的根目录新加shims-vue.d.ts 内容如下 即可绕过类型检查 

```ts
declare module '*.vue' {
  import { DefineComponent } from 'vue'
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types
  const component: DefineComponent<{}, {}, any>
  export default component
}
```

#### **在线ico制作网站** 

网页的ico图片 比如vue图标 ->原则是制作一定要小
https://www.bitbug.net/

vue的id是全局唯一的



### 20250219

#### router-link

使用router-link包裹的组件 点击可以实现跳转

img alt属性 是如果没加载出来图片 会显示alt的内容

#### div同一行对齐

```css
display:flex
align-items:center
```



#### **使用栅格Grid**

Grid让菜单变化

这里面关闭自动换行

```vue
  <div id="global-header">
    <a-row :wrap="false">
      <a-col flex="400px">
        <router-link to="/">
          <div class="title-bar">
            <img src="../../assets/logo.jpg" alt="logo" class="logo" />
            <div class="title">智能云图库</div>
          </div>
        </router-link>
      </a-col>
      <a-col flex="auto">
        <a-menu v-model:selectedKeys="current" mode="horizontal" :items="items" class="menu"/>
      </a-col>
      <a-col flex="100px">
        <div>
          <a-button type="primary" href="/user/login">登录</a-button>
        </div>
      </a-col>
    </a-row>
  </div>
```

```vue
const handleClick = ({key}) => {
  alert(key);
  const router = useRouter();
  router.push(key);
};
   <a-col flex="auto">
        <a-menu
          v-model:selectedKeys="current"
          mode="horizontal"
          :items="items"
          class="menu"
          @click="handleClick"
        />
        
const items = ref<MenuProps["items"]>([
  {
    key: "/",
    icon: () => h(HomeOutlined),
    label: "主页",
    title: "主页",
  },
  {
    key: "/about",
    icon: () => h(AppstoreOutlined),
    label: "关于",
    title: "关于",
  },
]);
```



#### 前端根据接口文档生成工具 @umijs/openapi

1 编写openapi.js

```js
import {generateService} from '@umijs/openapi'
generateService({
  requestLibPath:"import request from '@/request'",
  schemaPath: 'http://localhost:8100/api/v2/api-docs',
  serversPath: './src',
})
```

2 编写命令

package.json 增加openapi: node openapi.js



#### 跨域另一种

前端脚手架解决

vite.config.ts 追加 proxy配置



**MybatisPlus的查询**

**分页查询 3.5.9之后 要引入插件**

**路由里面 name必须唯一**



### 20250228

#### 图像分享平台搭建

##### 1 需求分析

确保用户能够查看图片功能 上传功能仅限于管理员使用 优先实现的功能

1. 管理员功能

   + 图片的上传 创建
   + 图片管理
   + 图片修改 (编辑信息)

2. 用户功能

   + 查看与搜索图片列表 主页
   + 查看图片详情
   + 图片下载

   图片一般存储在云服务器上面 对象存储



##### 创建图片的业务流程

推荐上传图片时候直接保存记录 上传图片后 系统立即生成图片的完整数据结构 无需等待用户点击提交 就立即存储到数据库中 之后用户再填写其他信息

**如何解析图片的信息？**

根据需求，我们要获取的图片信息包括：**宽度、高度、宽高比、大小、格式、名称**。

主流的获取图片信息的方法主要有 2 种：

1. **在后端服务器直接处理图片**，比如 Java 库 ImageIO、Python 库 Pillow，还有更成熟的专业图像处理库 OpenCV 等。
2. **通过第三方云存储服务**（如腾讯云 COS、AWS S3）或图像处理 API（如 ImageMagick、ExifTool）**直接提取图片的元数据信息**。

推荐使用腾讯云 COS 对象存储来实现文件的上传和下载，腾讯云 COS 对象存储在图片上传时，通过**数据万象**服务直接获取到图片的各种基础信息：

**tips**

使用云api 能够在线调试API的值
https://console.cloud.tencent.com/api/explorer?Product=cvm&Version=2017-03-12&Action=DescribeRegions



#### **文件下载**

官方文档介绍了 2 种文件下载方式：

1. **直接下载到后端服务器**（适合服务器端处理文件）
2. **获取到文件下载输入流**（适合返回给前端用户）

**参考官方文档：**

- https://cloud.tencent.com/document/product/436/65937
- https://cloud.tencent.com/document/product/436/10199#.E4.B8.8B.E8.BD.BD.E5.AF.B9.E8.B1.A1

其实还有第 **3 种“下载”方式**：**直接通过 URL 路径访问**。适用于单一、可被用作公开访问的资源，比如头像、本项目中的公共图片。

------

**⚠ 对安全性要求较高的场景**，建议**先通过后端服务器**进行权限校验，然后从 COS 下载文件到服务器，再返回给前端。这样可以限制只有登录用户才能下载。

不过，也有更灵活的做法：

- **后端做权限校验 → 返回前端一个临时密钥** → 前端借助临时密钥直接从对象存储下载**（无需经过服务器二次中转）**，性能更好。

------

**对于目前的项目**，图片本身算是公开，**直接使用第三种方式**，凭借 **URL 链接** 访问即可。

但这里依然可以演示如何让文件下载到后端服务器中，具体步骤：

1. 先在 `CosManager` 中新增一个下载方法，通过指定文件的 **key** 获取存储信息……

（后续部分应与代码/实现细节有关。）

 

写入流的话是使用servlet来实现的

```java
/**
	 * 测试文件下载
	 * @param filepath 文件路径
	 * @param response 响应对象
	 */
	@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
	@GetMapping("/test/download")
	public void testDownloadFile(String filepath, HttpServletResponse response) {
		// 使用 try-with-resources 确保 COSObjectInputStream 自动关闭
		try (COSObjectInputStream cosObjectInput = cosManager.getObject(filepath).getObjectContent()) {
			// 将 InputStream 转为字节数组
			byte[] bytes = IOUtils.toByteArray(cosObjectInput);

			// 设置响应头，指定下载类型和文件名
			response.setContentType("application/octet-stream;charset=UTF-8");
			response.setHeader("Content-Disposition", "attachment; filename=" + filepath);

			// 写入响应输出流
			response.getOutputStream().write(bytes);
			//刷新到响应区去
			response.getOutputStream().flush();
		} catch (IOException e) {
			log.error("file download error,filepath = {}", filepath, e);
			throw new BusinessException(ErrorCode.SYSTEM_ERROR,"下载失败");
		}
	}
```



### 20250305

#### **通用文件上传服务**

之前虽然我们已经编写了通用的对象存储操作类 **CosManager**，但这个类并不能直接满足我们的图片上传需求。

比如：

- **图片是否符合要求？** 需要校验
- **上传到哪里？** 需要指定路径
- **如何解析图片？** 需要使用数据万象服务

所以，可以针对我们的项目，编写一个更贴合业务的**文件上传服务 `FileManager`**（这里用 `Service` 也可以），该服务提供**图片上传并返回图片解析信息**的方法。

```java
@Service
@Slf4j
public class FileManager {

    @Resource
    private CosClientConfig cosClientConfig;

    @Resource
    private CosManager cosManager;

    // ...
}
```



#### 如何修改Vue引入的组件的样式

使用deep属性例如

```CSS
.picture-upload :deep(.ant-upload){
    width:100% !important;
    height:100% !important;
    min-height:152px
    min
}
```



#### 除了select组件 ant-design-vue还有auto-complete组件 可以自动输入



### 20250312

#### 图片管理

1. 新建路由和菜单
2. 开发管理页面
3. ```vue
    <a-tag v-for="tag in JSON.parse(record.tags || '[]')" :key="tag">
                 {{ tag }}
               </a-tag>
   ```

   解决图片大小不一致问题 增加 object-fit: cover 会自动截取部分图片

#### 图片列表页（主页）

https://github.com/gk-shi/v3-waterfall 下拉瀑布流 

#### 图片详情页

#### 图片下载

```bash
npm install file-saver
npm i --save-dev @types/file-saver
```



### 20250325

#### 通过URL导入图片

需求分析 

为了提高上传图片的效率 支持输入远程的URL 直接将网上已有的图片加入到系统中



#### ▸ 方案设计

实现原理很简单，但是有一些细节需要注意：

##### 1）下载图片

后端服务器从指定的远程 URL 下载图片到本地临时存储。
 对于 Java 项目，可以直接使用 **Hutool** 的
 `HttpUtil.downloadFile` 方法一行代码完成。

------

##### 2）校验图片

跟验证本地文件一样，需要校验图片的格式、大小等。

传统的校验思路是：

- 先把文件下载到本地
- 再对本地文件进行校验

有没有更节省资源的方法呢？

------

##### 实际可以对 URL 本身进行校验

- 首先校验 URL 字符串本身是否合法，比如是否是一个**合理的 URL 地址**
- 可以使用 `HEAD` 请求来获取 URL 对应文件的元信息（如文件大小、格式等）
   `HEAD` 请求仅返回 HTTP 响应头信息，而**不会下载文件内容**，
   可大大降低网络流量的消耗

#### 3. 优化代码 - 模板方法模式

目前我们的 FileManager 文件中写了两种不同的上传文件的方法，但是我们会发现，这两种方法的**流程完全一致**，而且大多数代码都是相同的。

这种情况下，我们可以**要运用设计模式——模板方法模式**对代码进行优化。

模板方法模式是**行为型设计模式**，**适用于具有通用处理流程，但处理细节不同的情况**。通过定义一个抽象模板类，提供通用的业务流程处理逻辑，并将不同的部分定义为抽象方法，由子类具体实现。

在我们的场景中，两种文件上传方法的流程都是：

1. 校验文件
2. 获取上传地址
3. 获取本地临时文件
4. 上传到对象存储
5. 封装解析得到的图片信息
6. 清理临时文件

可以将这些流程抽象为一套模板（抽象类），将每个实现不一样的步骤都定义为一个抽象方法，比如：

1. 校验图片
2. 获取文件名称
3. 保存临时文件



### 20250331

为了帮助管理员快速丰富图片库、启动项目，需要提供批量从网络抓取并创建图片的功能。

但是要注意，不建议将该功能开放给普通用户！主要是为了防止滥用导致的版权问题、低质量内容的上传、服务器资源消耗等安全问题。因为普通用户滥用网络图片（爬虫）抓图功能开故障相当于断等用户爬虫狂传我们服务器的内容——要么带宽爆炸，要么严重 IP 被封禁。

方案设计的重点包括：

- 如何抓取图片
- 抓取和导入规则

思考 2 个问题：从哪里抓取图片？怎么抓取图片呢？

绝大多数的图片素材网站，都是有版权保护的，不建议大家操作，容易被封禁 IP 和账号。比较安全的方法是从搜索引擎中抓图，仅学习使用、不商用的话基本不会有什么风险。

这里我们选择进入 bing 搜索图片网站，可以看到很多图片，但是如何获取这些图片呢？



有 2 种常见的做法。第一种是请求到完整的页面内容后，对页面的 HTML 结构进行解析，提取到图片的地址，再通过 URL 下载；还有一种是直接调用后端获取图片地址的接口拿到图片数据。

要使用哪种方式，还是要具体情况具体分析，比如在调研过程中，发现直接从 bing 图片的首页抓取数据，可能会出现获取不到图片的情况。所以换一种策略，尝试去找接口。

按 F12 打开网络请求控制台，向下滚动图片时会触发新一波图片的加载，就能看到获取图片数据的接口了：

```
https://cn.bing.com/images/async?q=%s&mmasync=1
```

注意，URL 地址必须要添加 `mmasync=1` 参数，否则加载条数不对。

但是该接口返回的还是 HTML 文档结构，所以需要使用一个 HTML 文档解析库来提取图片地址，Java 中比较推荐 `jsoup`，非常地轻量。



#### Redis 分布式缓存

##### 一、分布式缓存简介

分布式缓存是指将缓存数据分布存储在**多个服务器**上，以便在高并发场景下提供更高的吞吐量和更好的容错性。

##### Redis 优势：

- **高性能**：基于内存操作，访问速度极快。  
  *单节点 Redis 的读写 QPS 可达 10w 次/秒！*
- **丰富的数据结构**：支持字符串、列表、集合、哈希、位图等，适合多种结构存储。
- **分布式支持**：通过 Redis Cluster 构建高可用、高性能的分布式缓存，还支持哨兵机制提升可用性，提升集群扩展性。

##### 二、缓存设计

场景需求：

- 缓存首页的图片列表数据（如接口：`listPictureVOByPage`）
- 缓存三要素：
  - **key**
  - **value**
  - **过期时间（TTL）**

1）缓存 Key 设计

接口支持传入不同的查询条件，返回数据不同，因此**查询条件要参与生成 key**。

- 查询条件对象应转换为 JSON 字符串。
- 为避免 key 过长（JSON 会比较长），建议用哈希算法（如 **MD5**）对其压缩。
- 为避免多个项目之间 key 冲突，建议在 key 前增加业务前缀。

Key 设计结构示例：

```
业务前缀:接口名:md5(查询条件JSON)
例如：picture:listPictureVOByPage:fae2bdc1e8...
```



#### Caffeine 本地缓存

##### 一、本地缓存简介

当应用需要频繁访问某些数据时，可以将这些数据缓存到应用的内存中（例如 JVM 中）；下次访问时，直接从内存读取，而不需要经过网络或其他存储系统。

##### 本地缓存的特点：

- 访问速度快
- 但无法在多个服务器间共享数据，不方便扩容

##### 适合使用本地缓存的场景：

- 数据访问量有限的小型数据集
- 不需要服务器共享的单机应用
- 高频、低延迟的访问场景（如用户临时会话信息、短期热点数据）

##### 二、Caffeine 简介

对于 Java 项目，**Caffeine** 是主流的本地缓存技术，拥有极高的性能和丰富的功能。例如：

- 精确控制缓存数量和大小
- 支持缓存过期
- 支持各种缓存淘汰策略
- 支持异步操作、线程安全

📌 鱼皮建议：本地缓存不需要引入额外中间件，成本更低。如果只是想提高访问性能，**优先考虑本地缓存而不是分布式缓存**。

##### 三、缓存设计

本地缓存的设计和分布式缓存类似，但有两个区别：

1. 本地缓存需要自己创建初始化缓存容器（通常是 `new HashMap`，但推荐用 Caffeine 管理）
2. 本地缓存 key 的设计可以比分布式缓存更简洁，不用考虑多系统前缀等问题



对图片进行压缩处理 优化上传步骤

格式上，有 2 种选择：

1）**WebP**：由 Google 开发的现代图片格式，支持有损和无损压缩。相比传统格式：

- 比 PNG 文件小约 26%
- 比 JPEG 文件小约 25%-34%
- 支持透明背景（Alpha 通道）
- 兼容性：大部分主流浏览器（如 Chrome、Edge、Firefox 等）均已支持 WebP

2）**AVIF**：基于 AV1 视频编码技术的图片格式，压缩率更高。

- 比 WebP 的文件大小更小，画质更优
- 支持透明背景和高动态范围（HDR）

------

虽然 AVIF 看起来更好，但目前兼容性没有 WebP 要好，为了保证图片在不同浏览器都能正常加载，**建议选择 WebP 格式**。

### 上传图片时实时压缩：优劣对比

| 方式       | 优势                                                         | 劣势                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 下载时压缩 | 1. 接入便捷，无需大的开发<br>2. 按需压缩，按量付费，访问时不会产生额外的成本 | - 针对图片数量多、访问频次低的场景，压缩费用可能高于节省的流量费<br>- 建议用户通过 CDN 分发图片 |
| 上传时压缩 | 一次压缩永久保存，访问时无额外压缩费用                       | 1. 如果原图与压缩图各存一份，短期内节省存储费，但长期来看可能压缩成本更低<br>2. 若仅保存压缩图，avif 格式不如 jpg、png 等格式通用，某些场景可能无法预览 |

Curator 可以实现Zookeeper的分布式锁



浏览器缓存 加上Cache-Control 就可以允许缓存到本地

1 Cache-Control：public Maxage 最大过期时间

2 Cache-Control: private,no cache 缓存可以被客户端存储 每次使用之前要验证有效性 ->经常变的 比如用户个人页

3 Cache-Control:no store 敏感内容 禁止使用缓存

CDN里面可以缓存 配置浏览器缓存规则

**上传优化**

使用压缩 缩略图技术 懒加载等等

**图片存储优化**

数据沉降 老数据下降 新数据上升 将长时间没有访问的 自动放到访问频率低的 在对象存储中 进行设置

冷热数据分离=>同一个系统 同时优化性能和成本

**数据清理策略**

1 立即清理 

2 手动清理

3 定期清理

系统设置规则 使用定时任务进行执行

4 惰性清理

等到系统性能 或者资源有问题时候再进行执行



#### 空间模块

**需求分析**

对于空间模块，通常要有这些功能：

- 【管理员】管理空间
- 用户创建私有空间
- 私有空间权限控制
- 空间级别和限额控制

看起来简单，但其实每个需求的细节都非常多，具体分析每个需求：

1）【管理员】管理空间：管理员可用，可以对整个系统中的空间进行管理，比如搜索空间、编辑空间、删除空间。

2）用户创建私有空间：用户可以创建**最多一个**私有空间，并且在私有空间内自由上传和管理图片。

3）私有空间权限控制：用户仅能访问和管理自己私有空间和其中的图片，私有空间的图片不会展示在公共图库，也不需要管理员审核。

4）空间级别和限额控制：每个空间有不同的级别（如普通版和专业版），对应了不同的容量和图片数量限制，如果超过限制则无法继续上传图片。



### 用户创建私有空间

用户可以自主创建私有空间，但是必须要加限制，**最多只能创建一个**。

需要开发创建空间服务，该服务较为复杂，我们要先整理下流程。

------

#### 1. 创建空间流程

流程如下：

1. 填充参数默认值
2. 校验参数
3. 校验权限，**非管理员只能创建普通级别的空间**
4. 控制同一用户只能创建一个私有空间

------

如何保证一个用户只能建一个私有空间呢？

最粗暴的方式是给空间表加上 userId 加上唯一索引，但由于后续用户还可以创建团队空间，这种方式不利于扩展。

所以我们采用**加锁 + 事务**的方式实现。



#### 以图搜图

1提取图片颜色 使用OpenCv或者云服务的API 提取图片颜色特征 采用主色调 颜色直方图

2 存储颜色特征 将颜色特征存到DB 方便后续检索

3 用户查询输入 根据用户指定颜色 与数据库颜色比对 进行相似度计算(欧式距离 余弦相似度)

4 返回结果 按照相似度排序 优先返回最符合用户要求数据





## 一、基础图片编辑

### 需求分析

在日常的图‎片管理中，用户经常⁡需要对图片进行简单‍处理，比如裁剪多余⁢部分、旋转图片、放大缩‍小尺寸等。

因此，我们‎首先要引入基础图片⁡编辑功能，帮助用户‍快速完成以下操作：

- 裁剪：支持按固定比例或自由裁剪
- 旋转：提供顺时针、逆时针旋转功能

这个功能非常适合上传证件照之类的场景。

注意，该功‎能不需要限制仅在空⁡间内才能使用，公共‍图库也可以支持。

### 方案设计

图片编辑功‎能的实现以前端为主⁡，编辑完成后通过调‍用现有的图片上传接⁢口，将编辑后的图片保‍存至平台。

具体业务流程：

1. 在图片上传页面，如果用户已上传图片，页面会展示“编辑图片”按钮。
2. 用户点击“编辑图片”后，将打开图片编辑的弹窗组件，支持裁剪、旋转等操作。
3. 用户确认编辑后，会调用图片上传接口，将编辑后的新图片保存至平台，同时更新图片信息。

其实还有另一种设计，在‎用户每次选择本地或 URL 图片时，先不调用⁡后端的图片上传接口，而是自动弹出图片编辑弹窗‍组件，编辑完后再保存。但这样做就不是 “扩展⁢功能” 而是 “修改已有功能”，涉及到的代码‍改动会更多，感兴趣的同学可以尝试实现。

💡 这个‎地方也能体现出方案⁡设计的重要性，可以‍通过合适地改变业务⁢流程，降低开发成本‍，并让项目更利于维护扩展。

### 前端开发

#### 1、图片编辑组件

图片编辑是个比较常见的功能，一般会有现成的库可以直接用。经过调研，选用开源的 [vue-cropper 组件](https://github.com/xyxiao001/vue-cropper?tab=readme-ov-file#2-引入-vue-cropper)。

1）引入组件

参考官方文‎档引入，注意要引入 ⁡Vue3 版本的： ‍          ⁢          ‍           

![img](https://pic.code-nav.cn/course_picture/1608440217629360130/MvLCMAYcSu9FjuC2.webp)

安装依赖：‎         ⁡         ‍         ⁢     

```java
▼java

复制代码npm install vue-cropper@next
```

鱼皮编写本‎教程时，使用的 v⁡ue-croppe‍r 版本是 1.1⁢.4，最好跟教程‍保持一致。

在 `main.ts` 中引入依赖：

```typescript
▼typescript复制代码import VueCropper from 'vue-cropper';
import 'vue-cropper/dist/index.css'

app.use(VueCropper)
```

2）新建图‎片编辑组件 Imag⁡eCropper。我‍们要开发的组件结构包⁢括两部分：上方为图片‍预览区，下方为操作栏。

在哪里使用图片编辑组件呢？

根据我们的方案‎设计，图片编辑不应该和任何一⁡种上传图片的方式（本地图片 ‍/ URL 上传）进行绑定，⁢是在上传完成后才能编辑，所以‍应该在图片上传页面引入。

先硬编码要编辑的图片 url：

```vue
▼vue

复制代码<ImageCropper imageUrl="https://avatars2.githubusercontent.com/u/15681693?s=460&v=4" />
```

可以参考 [官方 Demo](https://codepen.io/xyxiao001/pen/yLooYKg) 实现组件，依次完成放大、缩小、左旋、右旋操作：

```vue
▼vue复制代码<template>
  <div class="image-cropper">
    <vue-cropper
      ref="cropperRef"
      :img="imageUrl"
      :autoCrop="true"
      :fixedBox="false"
      :centerBox="true"
      :canMoveBox="true"
      :info="true"
      outputType="png"
    />
    <div style="margin-bottom: 16px" />
    <!-- 图片操作 -->
    <div class="image-cropper-actions">
      <a-space>
        <a-button @click="rotateLeft">向左旋转</a-button>
        <a-button @click="rotateRight">向右旋转</a-button>
        <a-button @click="changeScale(1)">放大</a-button>
        <a-button @click="changeScale(-1)">缩小</a-button>
      </a-space>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

interface Props {
  imageUrl?: string
}

const props = defineProps<Props>()

// 编辑器组件的引用
const cropperRef = ref()

// 向左旋转
const rotateLeft = () => {
  cropperRef.value.rotateLeft()
}

// 向右旋转
const rotateRight = () => {
  cropperRef.value.rotateRight()
}

// 缩放
const changeScale = (num: number) => {
  cropperRef.value.changeScale(num)
}
</script>

<style scoped>
.image-cropper {
  text-align: center;
}
  
.image-cropper .vue-cropper {
  height: 400px;
}
</style>
```

3）编写 “确认按钮”：

```vue
▼vue复制代码<a-space>
  <a-button @click="rotateLeft">向左旋转</a-button>
  <a-button @click="rotateRight">向右旋转</a-button>
  <a-button @click="changeScale(1)">放大</a-button>
  <a-button @click="changeScale(-1)">缩小</a-button>
  <a-button type="primary" :loading="loading" @click="handleConfirm">确认</a-button>
</a-space>
```

点击后，调‎用 cropper⁡ 的 getCro‍pBlob 函数，⁢可以获得裁切后的文‍件：

```typescript
▼typescript复制代码// 确认裁剪
const handleConfirm = () => {
  cropperRef.value.getCropBlob((blob: Blob) => {
    // blob 为已裁切的文件
  })
}
```

效果如图：

![img](https://pic.code-nav.cn/course_picture/1608440217629360130/usSOIIMmvbfRwjWM.webp)

💡 如果‎想要点击确认后下载⁡图片，可以参考 d‍emo 的代码实现⁢：

![img](https://pic.code-nav.cn/course_picture/1608440217629360130/zZqNI1NVfgenfywq.webp)

#### 2、图片编辑弹窗

将上一步开发的图片编辑组件套到 [Ant Design 的弹框组件](https://antdv.com/components/modal-cn) 内。

1）把最外层从 `div` 改为 `a-modal`，注意一定要将 class 类名加在 modal 上，否则样式无法正确添加：

```vue
▼vue复制代码<a-modal class="image-cropper" v-model:visible="visible" title="编辑图片" :footer="false" @cancel="closeModal">
  ... 原有代码
</a-modal>
```

2）参考图‎片分享弹窗组件，补⁡充控制弹窗显示隐藏‍的相关代码，并对外⁢暴露打开弹窗的 o‍penModal 函数：

```typescript
▼typescript复制代码// 是否可见
const visible = ref(false)

// 打开弹窗
const openModal = () => {
  visible.value = true
}

// 关闭弹窗
const closeModal = () => {
  visible.value = false
}

// 暴露函数给父组件
defineExpose({
  openModal,
})
```

#### 3、上传编辑后的图片

点击确认后，需‎要上传编辑后的图片。我们可以⁡把图片编辑组件当做是图片上传‍组件的一种，而不和任何一种上⁢传图片的方式（本地图片 / ‍URL 上传）进行绑定。

1）参考图‎片上传组件的属性，⁡给组件补充 pic‍ture 和 sp⁢aceId、onS‍uccess 属性：

```typescript
▼typescript复制代码interface Props {
  imageUrl?: string
  picture?: API.PictureVO
  spaceId?: number
  onSuccess?: (newPicture: API.PictureVO) => void
}
```

2）编写上传函数‎。点击确认后将 blob 数据⁡转换为 file 对象，然后就‍可以复用图片上传组件的提交函数⁢了，上传成功后会传递新图片信息‍给父组件、并关闭弹窗。代码如下：

```typescript
▼typescript复制代码const loading = ref<boolean>(false)

// 确认裁剪
const handleConfirm = () => {
  cropperRef.value.getCropBlob((blob: Blob) => {
    const fileName = (props.picture?.name || 'image') + '.png'
    const file = new File([blob], fileName, { type: blob.type })
    // 上传图片
    handleUpload({ file })
  })
}

/**
 * 上传
 * @param file
 */
const handleUpload = async ({ file }: any) => {
  loading.value = true
  try {
    const params: API.PictureUploadRequest = props.picture ? { id: props.picture.id } : {}
    params.spaceId = props.spaceId
    const res = await uploadPictureUsingPost(params, {}, file)
    if (res.data.code === 0 && res.data.data) {
      message.success('图片上传成功')
      // 将上传成功的图片信息传递给父组件
      props.onSuccess?.(res.data.data)
      closeModal();
    } else {
      message.error('图片上传失败，' + res.data.message)
    }
  } catch (error) {
    message.error('图片上传失败')
  } finally {
    loading.value = false
  }
}
```

#### 4、使用图片编辑弹窗组件

在创建图片‎页面使用组件，可以⁡在图片下方补充一个‍编辑按钮，点击编辑⁢按钮后打开弹窗：

```vue
▼vue复制代码<div v-if="picture" class="edit-bar">
  <a-button :icon="h(EditOutlined)" @click="doEditPicture">编辑图片</a-button>
  <ImageCropper
    ref="imageCropperRef"
    imageUrl="https://avatars2.githubusercontent.com/u/15681693?s=460&v=4"
    :picture="picture"
    :spaceId="spaceId"
    :onSuccess="onCropSuccess"
  />
</div>
```

编辑图片事件函数：

```typescript
▼typescript复制代码// 图片编辑弹窗引用
const imageCropperRef = ref()

// 编辑图片
const doEditPicture = () => {
  if (imageCropperRef.value) {
    imageCropperRef.value.openModal()
  }
}

// 编辑成功事件
const onCropSuccess = (newPicture: API.PictureVO) => {
  picture.value = newPicture
}
```

适当优化一下 CSS 样式，增加上下边距和居中：

```css
▼css复制代码#addPicturePage .edit-bar {
  text-align: center;
  margin: 16px 0;
}
```

效果如图：

![img](https://pic.code-nav.cn/course_picture/1608440217629360130/2MO6rk1UPtZsL3f4.webp)

开发完成后‎，把 imageU⁡rl 的值改为要编‍辑的图片地址：

```vue
▼vue复制代码<ImageCropper
  ref="imageCropperRef"
  :imageUrl="picture?.url"
  :picture="picture"
  :spaceId="spaceId"
  :onSuccess="onSuccess"
/>
```

结果，发现图片无法正常显示，会出现跨域问题！

![img](https://pic.code-nav.cn/course_picture/1608440217629360130/bPalFuMzoA9LSOXH.webp)

#### 5、图片跨域问题解决

跨域问题之‎前我们已经经历过了⁡，是因为前端域名和‍服务器（对象存储）⁢的域名不一样导致的‍。

解决跨域问题的方式‎有很多，因为我们的图片地址全部都是同⁡一个对象存储 URL，所以可以直接登‍录云平台来修改对象存储的跨域访问 C⁢ORS 设置，直接给特定的源站（域名‍ + 端口）开放跨域。如图：

![img](https://pic.code-nav.cn/course_picture/1608440217629360130/fLXLefJh8It2oIei.webp)

然后再次测试编辑图片功能，图片就正常加载了：

![img](https://pic.code-nav.cn/course_picture/1608440217629360130/LD6U0s0WrmzSzobC.webp)

#### 扩展知识 - 通过代理解决跨域

可以通过 V‎ite 自带的本地代理⁡服务器，先替换图片的访‍问地址为前端地址，然后⁢通过代理服务器转发到对‍象存储路径，实现访问。

获取图片的参考代码：

```typescript
▼typescript复制代码/**
 * 获取图片 blob 对象和 base64
 * @param url 图片 url
 * @param cb 回调函数,返回 blob url 和 base64
 */
export const fetchImageAsBlob = async (
  url?: string,
  cb?: (blobUrl: string, base64: string) => void,
) => {
  if (!url) return
  const formatUrl = url.replace('https://pic.code-nav.cn', window.location.origin)
  try {
    const response = await fetch(formatUrl)
    if (!response.ok) {
      throw new Error('图片加载失败')
    }
    const imageBlob = await response.blob()
    const objectUrl = URL.createObjectURL(imageBlob)

    // 转换为 base64
    const reader = new FileReader()
    reader.readAsDataURL(imageBlob)
    reader.onloadend = () => {
      const base64 = reader.result as string
      cb?.(objectUrl, base64)
    }
  } catch (error: any) {
    console.log(error)
  }
}
```

参考 vite 配置：

```typescript
▼typescript复制代码server: {
  host: 'localhost',
  // 代理
  proxy: {
    // 改为你的图片存储 url 前缀
    '/yu_picture': {
      // 改为你的对象存储域名
      target: 'https://codefather.cn',
      changeOrigin: true,
    }
  },
},
```

### 扩展

1）优化业务‎流程：在图片上传前，先触⁡发编辑弹窗，完成图片裁剪‍后再上传到后端。这样需要⁢将编辑图片整合到图片上传‍组件内部，而不是平级的关系。

2）支持调整‎裁剪区域的固定比例（比如⁡ 16:9），实现思路是‍利用 vue-cropp⁢er 组件的 fixed‍Number 属性，参考代码：

```vue
▼vue复制代码<!-- 比例选择 -->
<div class="aspect-ratio-selector">
  <a-radio-group v-model:value="aspectRatio" button-style="solid">
    <a-radio-button value="free">自由比例</a-radio-button>
    <a-radio-button value="1:1">1:1</a-radio-button>
    <a-radio-button value="4:3">4:3</a-radio-button>
    <a-radio-button value="16:9">16:9</a-radio-button>
    <a-radio-button value="3:4">3:4</a-radio-button>
    <a-radio-button value="9:16">9:16</a-radio-button>
  </a-radio-group>
</div>

<vue-cropper
  ref="cropperRef"
  :img="imageUrl"
  :autoCrop="true"
  :fixedBox="false"
  :centerBox="true"
  :canMoveBox="true"
  :info="true"
  outputType="png"
  :fixed="aspectRatio !== 'free'"
  :fixedNumber="currentAspectRatio"
/>

const aspectRatio = ref('free')

// 计算当前宽高比
const currentAspectRatio = computed(() => {
  if (aspectRatio.value === 'free') return [0, 0]
  const [width, height] = aspectRatio.value.split(':').map(Number)
  return [width, height]
})
```

3）支持图片的任意角度旋转操作

4）支持对图片尺寸进行等比例放大的操作



# 团队空间

## 本节重点

从本节开始我们‎将进行项目第三阶段 —— 团⁡队空间的开发，让项目能够面向‍ B 端（企业）提供服务，比⁢如作为团队共享素材、团队活动‍相册等，增强项目的商业价值。

本节先给项目增加团队共享空间的能力，大纲：

- 团队空间需求分析
- 团队空间方案设计
- 团队空间后端开发
- 团队空间前端开发

本节学完后‎，你应该能够掌握一⁡个团队协作系统的方‍案设计和开发。

⭐️ 友情‎提示，本节涉及的后⁡端新技术较多，学习‍难度略大，而且细节⁢很多，请勿必仔细学‍习！

## 一、需求分析

之前我们已‎经完成了私有空间模⁡块，团队空间和它类‍似，我们可以拆分为⁢ 4 个需求：

1）创建团队共享空间

用户可以创建 **最多一个** 团队共享空间，用于团队协作和资源共享，空间管理员拥有私有空间的所有能力，包括自由上传图片、检索图片、管理图片、分析空间等。

2）空间成员管理

- 成员邀请：空间管理员可以邀请新成员加入团队，共享空间内的图片。
- 设置权限：空间管理员可以为成员设置不同的角色（如查看者、编辑者、管理员），控制成员的权限范围。

3）空间成‎员权限控制：仅特定⁡角色的成员可访问或‍操作团队空间内⁢的图片。

4）空间数据‎管理：考虑到团队空间的图⁡片数量可能比较多，可以对‍特定空间的数据进行单独的⁢管理，而不是和公共图库、‍私有空间的图片混在一起。

## 二、方案设计

让我们先依次分析上述需求，并思考对应的解决方案。

### 创建团队共享空间

之前已经开发了‎空间模块，团队空间可以直接⁡复用私有空间的大多数能力。‍因此可以给空间表新增一个 ⁢spaceType 字段，‍用于区分私有和团队空间。

```sql
ALTER TABLE space
    ADD COLUMN spaceType int default 0 not null comment '空间类型：0-私有 1-团队';

CREATE INDEX idx_spaceType ON space (spaceType);
```

### 空间成员管理

#### 1、业务流程

为了让项目更容易扩展，减少原有代码的修改，我们约定 **只有团队空间才有成员的概念**。

1）成员邀‎请：空间管理员可以⁡直接输入成员 id‍ 来添加新成员，无⁢需该用户确认，这样‍可以提高开发效率。

2）设置权‎限：空间管理员可以⁡为已加入成员设置不‍同的角色，控制成员⁢的权限范围，类似于编辑‍成员信息。

```sql
-- 空间成员表
create table if not exists space_user
(
    id         bigint auto_increment comment 'id' primary key,
    spaceId    bigint                                 not null comment '空间 id',
    userId     bigint                                 not null comment '用户 id',
    spaceRole  varchar(128) default 'viewer'          null comment '空间角色：viewer/editor/admin',
    createTime datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    -- 索引设计
    UNIQUE KEY uk_spaceId_userId (spaceId, userId), -- 唯一索引，用户在一个空间中只能有一个角色
    INDEX idx_spaceId (spaceId),                    -- 提升按空间查询的性能
    INDEX idx_userId (userId)                       -- 提升按用户查询的性能
) comment '空间用户关联' collate = utf8mb4_unicode_ci;

```

注意几个细节：

1. 给 spaceId 和 userId 添加唯一索引，确保同一用户在同一空间中只能有一个角色（不能重复加入）。由于有唯一键，不需要使用逻辑删除字段，否则无法退出后再重新加入。

2. 给关联字段添加索引，提高查询效率

3. 为了跟用户自身在项目中的角色 userRole 区分开，空间角色的名称使用 spaceRole

   **为保证逻辑的统一，创建团队空间时要自动将创建人作为空间管理员，保存到空间成员表中。**

   ### 空间成员权限控制

   仅特定角色的成员可访问或操作团队空间内的图片。

   团队空间的权‎限管理可比私有空间的权限⁡复杂多了，除了创建人外还‍有其他成员，涉及到查看图⁢片、上传图片、管理空间图‍片、管理空间等多种不同的权限。

   #### 1、RBAC 权限控制

   对于复杂的权限控制场景，我们可以采用经典的 RBAC 权限控制模型（基于角色的访问控制，Role-Based Access Control），核心概念包括 **用户、角色、权限**。

   - 一个用户可以有多个角色
   - 一个角色可以有多个权限

   这样一来，就可以灵活地配置用户具有的权限了。

   一般来说，标准的 RBA‎C 实现需要 5 张表：用户表、角色表、权限表⁡、用户角色关联表、角色权限关联表，还是有一定开发成‍本的。由于我们的项目中，团队空间不需要那么⁢多角色，可以简化 RBAC 的实现方式，比如将‍角色和权限直接定义到配置文件中。

   #### 2、角色和权限定义

   本项目的角色：

   | 角色   | 描述                          |
   | ------ | ----------------------------- |
   | 浏览者 | 仅可查看空间中的图片内容      |
   | 编辑者 | ‎ 可查看、上传和编⁡辑图片内容   |
   | 管理员‍ | 拥有管理空间⁢和成员的所有权限 ‍ |

   本项目的权限：

   | 权限键           | 功能名称 | 描述                         |
   | ---------------- | -------- | ---------------------------- |
   | spaceUser:manage | 成员管理 | 管理空间成员，添加或移除成员 |
   | picture:view     | 查看图片 | 查看空间中的图片内容         |
   | picture:upload   | 上传图片 | 上传图片到空间中             |
   | picture:edit     | 修改图片 | 编辑已上传的图片信息         |
   | picture:delete   | 删除图片 | 删除空间中的图片             |

   角色与权限映射：

   | 角色   | 对应权限键                                                   | 可执行功能                                       |
   | ------ | ------------------------------------------------------------ | ------------------------------------------------ |
   | 浏览者 | picture:view                                                 | 查看图片                                         |
   | 编辑者 | picture:view, picture:upload, picture:edit, picture:delete   | 查看图片、上传图片、修改图片、删除图片           |
   | 管理员 | spaceUser:manage, picture:view, picture:upload, picture:edit, picture:delete | 成员管理、查看图片、上传图片、修改图片、删除图片 |

   #### 3、权限校验实现方案

   RBAC ‎只是一种权限设计模⁡型，我们在 Jav‍a 代码中如何实现⁢权限校验呢？

   1）最直接的‎方案是像之前校验私有空间⁡权限一样，封装个团队空间‍的权限校验方法；或者类似⁢用户权限校验一样，写个注‍解 + AOP 切面。

   2）对于复杂‎的角色和权限管理，可以选⁡用现成的第三方权限校验框‍架来实现，编写一套权限校⁢验规则代码后，就能整体管‍理系统的权限校验逻辑了。

   其实在本项目中，由于角色和权限不多，采用方案 1 实现会更方便一些，我也建议大家优先选择这种方案。方案 2 的代码量虽然未必比方案 1 少，但是会让整个系统的权限校验逻辑更加清晰，为了让大家后续能够应对更复杂的权限管理需求，此处鱼皮给大家讲解方案 2，并选用国内主流的 [权限校验框架 Sa-Token](https://sa-token.cc/doc.html#/start/example) 实现。

   ### 空间数据管理

   考虑到团队‎空间的图片数量可能⁡比较多，可以对特定‍空间的数据进行单独⁢的管理。

   如何对数据进行单独的管理呢？

   #### 1、图片信息数据

   可以给每个团队空间单独创建一张图片表 `picture_{spaceId}`，也就是分库分表中的 `分表`，而不是和公共图库、私有空间的图片混在一起。这样不仅查询空间内的图片效率更高，还便于整体管理和清理空间。**但是要注意，仅对旗舰版空间生效，否则分表的数量会特别多，反而可能影响性能。**

   注意，我们要实现的，还不是普通的静态分表，而是会随着新增空间不断增加分表数量的动态分表，会使用分库分表框架 [Apache ShardingSphere](https://shardingsphere.apache.org/) 带大家实现。

   #### 2、图片文件数据

   已经将每个‎空间的图片存到不同⁡的路径中了，实现了‍隔离，无需额外开发⁢。

   ------

   💡 你会发现‎，我们在设计上就将团队空间和⁡私有空间隔离，仅对团队空间应‍用成员管理、权限控制、动⁢态分表。这样可以尽量减少对原有代‍码的改动，避免出现问题。

   

   Sa-Token‎ 默认将数据（比如用户登录态）保⁡存在内存中，此模式读写速度最快，‍且避免了序列化与反序列化带来的性⁢能消耗，但缺点是重启后数据会丢失‍、无法在分布式环境中共享数据。

   我们项目中既然已经使用了 Redis，那么可以 [参考官方文档](https://sa-token.cc/doc.html#/up/integ-redis) 让 Sa-Token 整合 Redis，将用户的登录态等内容保存在 Redis 中。

   此处选择 ‎jackson 序⁡列化方式整合 Re‍dis，这样存到 ⁢Redis 的数据‍是可读的：

​       

​        2）了解 Sa-Token 的基本用法

Sa-To‎ken 的使用方式⁡比较简单，首先是用‍户登录时调用 lo⁢gin 方法，产生‍一个新的会话：

```java
StpUtil.login(10001);
```

还可以给会话保存一些信息，比如登录用户的信息：

```java
StpUtil.getSession().set("user", user)
```

接下来你就‎可以判断用户是否登⁡录、获取用户信息了‍，可以通过代码进行⁢判断：

```java
// 检验当前会话是否已经登录, 如果未登录，则抛出异常：`NotLoginException`
StpUtil.checkLogin();
// 获取用户信息
StpUtil.getSession().get("user");
```

也可以参考 [官方文档](https://sa-token.cc/doc.html#/use/at-check)，使用注解进行鉴权：

```java
// 登录校验：只有登录之后才能进入该方法 
@SaCheckLogin                        
@RequestMapping("info")
public String info() {
    return "查询用户信息";
}
```

这是 Sa‎-Token 最基⁡本的用法，下面我们‍正式在项目中使用 ⁢Sa-Token。

使用Sa-Token 整合redis

```xml
<!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） -->
<dependency>
    <groupId>cn.dev33</groupId>
    <artifactId>sa-token-redis-jackson</artifactId>
    <version>1.39.0</version>
</dependency>
<!-- 提供Redis连接池 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```



#### 第二步 使用Kit模式 建立多账号体系

```

```

